from flask import Flask, request, jsonify
from PIL import Image
import requests
from io import BytesIO
import base64
import os
from supabase import create_client, Client
import google.generativeai as genai

# --- Flask App ---
app = Flask(__name__)

# --- Supabase ---
SUPABASE_URL = os.getenv("SUPABASE_URL", "https://xetomtmbtiqwfisynrrl.supabase.co")
SUPABASE_KEY = os.getenv("SUPABASE_KEY", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhldG9tdG1idGlxd2Zpc3lucnJsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczNDg5NDMsImV4cCI6MjA3MjkyNDk0M30.eJNpLnTwzLyCIEVjwSzh3K1N4Y0mA9HV914pY6q3nRo")
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# --- Gemini ---
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable is required")
genai.configure(api_key=GEMINI_API_KEY)

# --- Utility: Convert image to base64 ---
def image_to_base64(img: Image.Image) -> str:
    buf = BytesIO()
    img.save(buf, format="PNG")
    return base64.b64encode(buf.getvalue()).decode("utf-8")

@app.route("/", methods=["GET"])
def home():
    return jsonify({"status": "ok", "message": "Xaze Try-On Backend Running ðŸš€"})

@app.route("/tryon", methods=["POST"])
def tryon():
    try:
        data = request.get_json() or {}
        user_id = data.get("user_id")
        product_id = data.get("product_id")
        user_image_url = data.get("user_image_url")
        cloth_image_url = data.get("cloth_image_url")

        # Validate required fields
        missing_fields = []
        if not user_id:
            missing_fields.append("user_id")
        if not product_id:
            missing_fields.append("product_id")
        if not user_image_url:
            missing_fields.append("user_image_url")
        if not cloth_image_url:
            missing_fields.append("cloth_image_url")

        if missing_fields:
            return jsonify({
                "status": "error", 
                "message": f"Missing required fields: {', '.join(missing_fields)}"
            }), 400

        # Download input images
        user_response = requests.get(user_image_url, timeout=30)
        cloth_response = requests.get(cloth_image_url, timeout=30)
        
        if user_response.status_code != 200 or cloth_response.status_code != 200:
            return jsonify({"status": "error", "message": "Failed to download images"}), 400

        user_img = Image.open(BytesIO(user_response.content))
        cloth_img = Image.open(BytesIO(cloth_response.content))

        # Convert to base64
        user_b64 = image_to_base64(user_img)
        cloth_b64 = image_to_base64(cloth_img)

        # Gemini Prompt
        prompt = """
        Overlay the clothing item onto the person realistically,
        making it look like they are wearing it. Match pose, proportions,
        and preserve natural look. Generate a high-quality image.
        """

        # Call Gemini
        model = genai.GenerativeModel("gemini-1.5-pro")  # Use a more capable model for image generation
        response = model.generate_content([
            {"mime_type": "image/png", "data": base64.b64decode(cloth_b64)},
            {"mime_type": "image/png", "data": base64.b64decode(user_b64)},
            prompt,
        ])

        # Extract generated image
        if not response or not response.candidates:
            return jsonify({"status": "error", "message": "No candidates returned from Gemini"}), 400

        img_data = None
        for part in response.candidates[0].content.parts:
            if part.function_call:
                # Handle function calls if any
                continue
            if hasattr(part, "inline_data") and part.inline_data and part.inline_data.data:
                img_data = base64.b64decode(part.inline_data.data)
                break

        if not img_data:
            return jsonify({"status": "error", "message": "No image generated by Gemini"}), 400

        result_img = Image.open(BytesIO(img_data))

        # Save to Supabase Storage
        file_name = f"tryon_results/{user_id}_{product_id}_{int(os.times())}.png"
        buf = BytesIO()
        result_img.save(buf, format="PNG")
        buf.seek(0)
        
        # Upload to Supabase
        upload_response = supabase.storage.from("images").upload(file_name, buf, {"upsert": True})
        if not upload_response.data:
            return jsonify({"status": "error", "message": "Failed to upload to Supabase"}), 500

        # Get public URL
        result_url = supabase.storage.from("images").get_public_url(file_name).data.public_url

        # Save metadata
        insert_response = supabase.table("tryon_results").insert({
            "user_id": user_id,
            "product_id": product_id,
            "user_image_url": user_image_url,
            "cloth_image_url": cloth_image_url,
            "result_url": result_url
        }).execute()

        if not insert_response.data:
            return jsonify({"status": "error", "message": "Failed to save metadata"}), 500

        return jsonify({"status": "success", "result_url": result_url})

    except requests.exceptions.RequestException as e:
        return jsonify({"status": "error", "message": f"Image download failed: {str(e)}"}), 500
    except Exception as e:
        print(f"Unexpected error: {str(e)}")  # Log for debugging
        return jsonify({"status": "error", "message": str(e)}), 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 5000)), debug=False)
